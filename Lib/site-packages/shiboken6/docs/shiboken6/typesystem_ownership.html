
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Object ownership</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/pyside.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="next" title="Solving compilation problems" href="typesystem_solving_compilation.html" />
    <link rel="prev" title="Type System Variables" href="typesystem_variables.html" /> 
  </head><body>
<div id="container">
<div class="header">
    <div class="header_container">
        <div class="logo"><a href="http://www.pyside.org"><img alt="PySide" src="_static/pysidelogo.png"/></a></div>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="typesystem_solving_compilation.html" title="Solving compilation problems"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="typesystem_variables.html" title="Type System Variables"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Shiboken  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="typesystem.html" accesskey="U">Type System Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Object ownership</a></li> 
      </ul>
    </div>
    </div>
</div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="object-ownership">
<span id="objectownership"></span><h1>Object ownership</h1>
<p>One of the main things a binding developer should have in mind is
how the C++ instances lives will cope with Python’s reference count.
The last thing you want is to crash a program due to a segfault
when your C++ instance was deleted and the
wrapper object tries to access the invalid memory there.</p>
<p>In this section we’ll show how Shiboken deals with object ownership
and parentship, taking advantage of the information provided by the
APIExtractor.</p>
<section id="ownership-basics">
<h2>Ownership basics</h2>
<p>As any python binding, Shiboken-based bindings uses reference counting
to handle the life of the wrapper object (the Python object that contains the
C++ object, do not confuse with the <em>wrapped</em> C++ object).
When a reference count reaches zero, the wrapper is deleted by Python garbage
collector and tries to delete the wrapped instance, but sometimes the wrapped
C++ object is already deleted, or maybe the C++ object should not be freed after
the Python wrapper go out of scope and die, because C++ is already taking care of
the wrapped instance.</p>
<p>This is not a concern for value types specified by <a class="reference internal" href="typesystem_specifying_types.html#value-type"><span class="std std-ref">value-type</span></a>, which can
be freely created, copied and destroyed, however object types specified by
<a class="reference internal" href="typesystem_specifying_types.html#object-type"><span class="std std-ref">object-type</span></a> pointing to C++ instances with life cycle constraints
may require attention.</p>
<p>In order to handle this, you should tell the
generator whether the instance’s ownership belongs to the binding or
to the C++ Library. When belonging to the binding, we are sure that the C++ object
won’t be deleted by C++ code and we can call the C++ destructor when the refcount
reaches 0. Otherwise, instances owned by C++ code can be destroyed arbitrarily,
without notifying the Python wrapper of its destruction.</p>
<p>By default, objects created in Python have ownership. A relevant case are
return values of virtual factory methods reimplemented in Python
(C++ Wrapper Code) which pass the bindings code. Objects obtained from C++
(for example, <code class="docutils literal notranslate"><span class="pre">QGuiApplication::clipoard()</span></code>) do not have ownership.</p>
<p>The <a class="reference internal" href="shibokenmodule.html#shiboken-module"><span class="std std-ref">Shiboken module</span></a> module provides the <code class="docutils literal notranslate"><span class="pre">dump()</span></code> utility function,
which prints the relevant information for an object.</p>
</section>
<section id="invalidating-objects">
<h2>Invalidating objects</h2>
<p>To prevent segfaults and double frees, the wrapper objects are invalidated.
An invalidated can’t be passed as argument or have an attribute or method accessed.
Trying to do this will raise RuntimeError.</p>
<p>The following situations can invalidate an object:</p>
<section id="c-taking-ownership">
<h3>C++ taking ownership</h3>
<blockquote>
<div><p>When an object is passed to a function or method that takes ownership of it, the wrapper
is invalidated as we can’t be sure of when the object is destroyed, unless it has a
<a class="reference internal" href="#ownership-virt-method"><span class="std std-ref">virtual destructor</span></a> or the transfer is due to the special case
of <a class="reference internal" href="#ownership-parent"><span class="std std-ref">parent ownership</span></a>.</p>
<p>Besides being passed as argument, the called object can have its ownership changed, like
the <cite>setParent</cite> method in Qt’s <cite>QObject</cite>.</p>
</div></blockquote>
</section>
<section id="invalidate-after-use">
<h3>Invalidate after use</h3>
<blockquote>
<div><p>Objects marked with <em>invalidate-after-use</em> in the type system description always are
virtual method arguments provided by a C++ originated call. They should be
invalidated right after the Python function returns (see <a class="reference internal" href="#invalidationafteruse"><span class="std std-ref">Invalidation after use</span></a>).</p>
</div></blockquote>
</section>
<section id="objects-with-virtual-methods">
<span id="ownership-virt-method"></span><h3>Objects with virtual methods</h3>
<blockquote>
<div><p>A little bit of implementation details (see also <a class="reference internal" href="typesystem_codegeneration.html#codegenerationterminology"><span class="std std-ref">Code Generation Terminology</span></a>):
virtual methods are supported by creating a C++ class, the <strong>shell</strong>, that inherits
from the class with virtual methods, the native one, and override those methods to check if
any derived class in Python also override it.</p>
<p>If the class has a virtual destructor (and C++ classes with virtual methods should have), this
C++ instance invalidates the wrapper only when the overridden destructor is called.</p>
<p>An instance of the <strong>shell</strong> is created when created in Python. However,
when  the object is created in C++, like in a factory method or a parameter
to a virtual function like <code class="docutils literal notranslate"><span class="pre">QObject::event(QEvent</span> <span class="pre">*)</span></code>, the wrapped object
is a C++ instance of the native class, not the <strong>shell</strong> one, and we cannot
know when it is destroyed.</p>
</div></blockquote>
</section>
</section>
<section id="parent-child-relationship">
<span id="ownership-parent"></span><h2>Parent-child relationship</h2>
<p>One special type of ownership is the parent-child relationship.
Being a child of an object means that when the object’s parent dies,
the C++ instance also dies, so the Python references will be invalidated.
Qt’s QObject system, for example, implements this behavior, but this is valid
for any C++ library with similar behavior.</p>
<section id="parentship-heuristics">
<span id="ownership-parent-heuristics"></span><h3>Parentship heuristics</h3>
<blockquote>
<div><p>As the parent-child relationship is very common, Shiboken tries to automatically
infer what methods falls into the parent-child scheme, adding the extra
directives related to ownership.</p>
<p>This heuristic will be triggered when generating code for a method and:</p>
<ul class="simple">
<li><p>The function is a constructor.</p></li>
<li><p>The argument name is <cite>parent</cite>.</p></li>
<li><p>The argument type is a pointer to an object.</p></li>
</ul>
<p>When triggered, the heuristic will set the argument named “parent”
as the parent of the object being created by the constructor.</p>
<p>The main focus of this process was to remove a lot of hand written code from
type system when binding Qt libraries. For Qt, this heuristic works in all cases,
but be aware that it might not when binding your own libraries.</p>
<p>To activate this heuristic, use the <a class="reference internal" href="shibokengenerator.html#parent-heuristic"><span class="std std-ref">–enable-parent-ctor-heuristic</span></a>
command line switch.</p>
</div></blockquote>
</section>
<section id="return-value-heuristics">
<span id="id1"></span><h3>Return value heuristics</h3>
<blockquote>
<div><p>When enabled, object returned as pointer in C++ will become child of the object on which the method
was called.</p>
<p>To activate this heuristic, use the command line switch
<a class="reference internal" href="shibokengenerator.html#return-heuristic"><span class="std std-ref">–enable-return-value-heuristic</span></a>.</p>
<p>To disable this heuristic for specific cases, specify <code class="docutils literal notranslate"><span class="pre">default</span></code> as
ownership:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;modify-argument</span> <span class="na">index=</span><span class="s">&quot;0&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;define-ownership</span> <span class="na">class=</span><span class="s">&quot;target&quot;</span> <span class="na">owner=</span><span class="s">&quot;default&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/modify-argument&gt;</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="common-pitfalls">
<h2>Common pitfalls</h2>
<section id="not-saving-unowned-objects-references">
<h3>Not saving unowned objects references</h3>
<blockquote>
<div><p>Sometimes when you pass an instance as argument to a method and the receiving
instance will need that object to live indefinitely, but will not take ownership
of the argument instance. In this case, you should hold a reference to the argument
instance.</p>
<p>For example, let’s say that you have a renderer class that will use a source class
in a setSource method but will not take ownership of it. The following code is wrong,
because when <cite>render</cite> is called the <cite>Source</cite> object created during the call to <cite>setSource</cite>
is already destroyed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">renderer</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">Source</span><span class="p">())</span>
<span class="n">renderer</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
</pre></div>
</div>
<p>To solve this, you should hold a reference to the source object, like in</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="n">Source</span><span class="p">()</span>
<span class="n">renderer</span><span class="o">.</span><span class="n">setSource</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">renderer</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</section>
</section>
<section id="ownership-management-in-the-typesystem">
<h2>Ownership Management in  the Typesystem</h2>
<section id="python-wrapper-code">
<h3>Python Wrapper Code</h3>
<p>For this code, the <code class="docutils literal notranslate"><span class="pre">class</span></code> attribute takes the value <code class="docutils literal notranslate"><span class="pre">target</span></code>
(see <a class="reference internal" href="typesystem_codegeneration.html#codegenerationterminology"><span class="std std-ref">Code Generation Terminology</span></a>).</p>
<section id="ownership-transfer-from-c-to-target">
<h4>Ownership transfer from C++ to target</h4>
<blockquote>
<div><p>When an object currently owned by C++ has its ownership transferred
back to the target language, the binding can know for sure when the object will be deleted and
tie the C++ instance existence to the wrapper, calling the C++ destructor normally when the
wrapper is deleted.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;modify-argument</span> <span class="na">index=</span><span class="s">&quot;1&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;define-ownership</span> <span class="na">class=</span><span class="s">&quot;target&quot;</span> <span class="na">owner=</span><span class="s">&quot;target&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/modify-argument&gt;</span>
</pre></div>
</div>
<p>A typical use case would be returning an object allocated in C++, for
example from <code class="docutils literal notranslate"><span class="pre">clone()</span></code> or other factory methods.</p>
</div></blockquote>
</section>
<section id="ownership-transfer-from-target-to-c">
<h4>Ownership transfer from target to C++</h4>
<blockquote>
<div><p>In the opposite direction, when an object ownership is transferred from the target language
to C++, the native code takes full control of the object life and you don’t
know when that object will be deleted, rendering the wrapper object invalid,
unless you’re wrapping an object with a virtual destructor,
so you can override it and be notified of its destruction.</p>
<p>By default it’s safer to just render the wrapper
object invalid and raise some error if the user tries to access
one of this objects members or pass it as argument to some function, to avoid unpleasant segfaults.
Also you should avoid calling the C++ destructor when deleting the wrapper.</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;modify-argument</span> <span class="na">index=</span><span class="s">&quot;1&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;define-ownership</span> <span class="na">class=</span><span class="s">&quot;target&quot;</span> <span class="na">owner=</span><span class="s">&quot;c++&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/modify-argument&gt;</span>
</pre></div>
</div>
<p>Use cases would be an returning a member object by pointer
or passing an object by pointer into a function where the class
takes ownership, for example
<code class="docutils literal notranslate"><span class="pre">QNetworkAccessManager::setCookieJar(QNetworkCookieJar</span> <span class="pre">*)</span></code>.</p>
</div></blockquote>
</section>
<section id="id2">
<h4>Parent-child relationship</h4>
<p>One special type of relationship is the parent-child. When an object is called
the parent of another object (the child), the former is in charge of deleting its
child when deleted and the target language can trust that the child will be alive
as long as the parent is, unless some other method can take the C++ ownership away from the parent.</p>
<p>One of the main uses of this scheme is Qt’s object system, with ownership among QObject-derived
classes, creating “trees” of instances.</p>
<blockquote>
<div><div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;modify-argument</span> <span class="na">index=</span><span class="s">&quot;this&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;parent</span> <span class="na">index=</span><span class="s">&quot;1&quot;</span> <span class="na">action=</span><span class="s">&quot;add&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/modify-argument&gt;</span>
</pre></div>
</div>
</div></blockquote>
<p>In this example, the instance with the method that is being invoked (indicated by ‘index=”this”’ on
modify-argument) will be marked as a child
of the first argument using the <cite>parent</cite> tag. To remove ownership, just use “remove” in the action attribute. <strong>Removing
parentship also transfers the ownership back to python.</strong></p>
<p>See <a class="reference external" href="http://doc.qt.io/qt-6/objecttrees.html">Object Trees and Object Ownership in Qt</a>.</p>
</section>
</section>
<section id="c-wrapper-code">
<h3>C++ Wrapper Code</h3>
<p>For this code, the <code class="docutils literal notranslate"><span class="pre">class</span></code> attribute takes the value <code class="docutils literal notranslate"><span class="pre">native</span></code>. The
modifications affect code called from within C++, typically when calling
virtual C++ methods reimplemented in Python
(see <a class="reference internal" href="typesystem_codegeneration.html#codegenerationterminology"><span class="std std-ref">Code Generation Terminology</span></a>).</p>
<section id="return-values-of-virtual-functions">
<h4>Return values of virtual functions</h4>
<p>The ownership of C++ objects returned by pointer should be set to <code class="docutils literal notranslate"><span class="pre">c++</span></code> to
prevent them from being deleted by Python, since objects created
in Python have ownership by default.</p>
<p>Ownership transfers specified for other arguments do not have any effect.</p>
</section>
<section id="invalidation-after-use">
<span id="invalidationafteruse"></span><h4>Invalidation after use</h4>
<p>Sometimes an object is created in C++ and passed as a virtual method call
argument and destroyed after the call returned
(see <a class="reference internal" href="#ownership-virt-method"><span class="std std-ref">Objects with virtual methods</span></a>).
In this case, you should use the <code class="docutils literal notranslate"><span class="pre">invalidate-after-use</span></code> attribute in the
<a class="reference internal" href="typesystem_modify_function.html#modify-argument"><span class="std std-ref">modify-argument</span></a> tag to mark the wrapper as invalid right after the
virtual method returns.</p>
<blockquote>
<div><div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;modify-argument</span> <span class="na">index=</span><span class="s">&quot;2&quot;</span> <span class="na">invalidate-after-use=</span><span class="s">&quot;yes&quot;</span><span class="nt">/&gt;</span>
</pre></div>
</div>
</div></blockquote>
<p>In this example the second argument will be invalidated after this method call.</p>
</section>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
    <a href="http://www.qt.io/"><img src="_static/logo_qt.png" alt="Qt" border="0" /></a>
    <a href="http://www.python.org"><img src="_static/logo_python.jpg" alt="Python" border="0" /></a>
    </div>
</div>
  </body>
</html>